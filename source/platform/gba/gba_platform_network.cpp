////////////////////////////////////////////////////////////////////////////////
//
// MIT License
//
// Copyright (c) 2020-2024 Evan Bowman
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
////////////////////////////////////////////////////////////////////////////////


#include "platform/platform.hpp"
#include "gba.h"
#include "platform_flags.hpp"
#include "gba_platform_audio.hpp"



static void __attribute__((noinline)) busy_wait(unsigned max)
{
    for (unsigned i = 0; i < max; i++) {
        __asm__ volatile("" : "+g"(i) : :);
    }
}



Platform::NetworkPeer::NetworkPeer()
{
}



static int multiplayer_is_master()
{
    return (REG_SIOCNT & (1 << 2)) == 0 and (REG_SIOCNT & (1 << 3));
}



// NOTE: you may only call this function immediately after a transmission,
// otherwise, may return a garbage value.
static int multiplayer_error()
{
    return REG_SIOCNT & (1 << 6);
}



// NOTE: This function should only be called in a serial interrupt handler,
// otherwise, may return a garbage value.


static bool multiplayer_validate_modes()
{
    // 1 if all GBAs are in the correct mode, 0 otherwise.
    return REG_SIOCNT & (1 << 3);
}



static bool multiplayer_validate()
{
    if (not multiplayer_validate_modes()) {
        return false;
    } else {
    }
    return true;
}



// The gameboy Multi link protocol always sends data, no matter what, even if we
// do not have any new data to put in the send buffer. Because there is no
// distinction between real data and empty transmits, we will transmit in
// fixed-size chunks. The receiver knows when it's received a whole message,
// after a specific number of iterations. Now, there are other ways, potentially
// better ways, to handle this situation. But this way seems easiest, although
// probably uses a lot of unnecessary bandwidth. Another drawback: the poller
// needs ignore messages that are all zeroes. Accomplished easily enough by
// prefixing the sent message with an enum, where the zeroth enumeration is
// unused.
static const int message_iters =
    Platform::NetworkPeer::max_message_size / sizeof(u16);


struct WireMessage
{
    u16 data_[message_iters] = {};
};



using TxInfo = WireMessage;
using RxInfo = WireMessage;


struct MultiplayerComms
{
    int rx_loss = 0;
    int tx_loss = 0;

    int rx_message_count = 0;
    int tx_message_count = 0;


    static constexpr const int tx_ring_size = 64;
    ObjectPool<TxInfo, tx_ring_size> tx_message_pool;

    int tx_ring_write_pos = 0;
    int tx_ring_read_pos = 0;
    TxInfo* tx_ring[tx_ring_size] = {nullptr};


    static constexpr const int rx_ring_size = 64;
    ObjectPool<RxInfo, rx_ring_size> rx_message_pool;

    int rx_ring_write_pos = 0;
    int rx_ring_read_pos = 0;
    RxInfo* rx_ring[rx_ring_size] = {nullptr};

    int rx_iter_state = 0;
    RxInfo* rx_current_message =
        nullptr; // Note: we will drop the first message, oh well.

    // The multi serial io mode always transmits, even when there's nothing to
    // send. At first, I was allowing zeroed out messages generated by the
    // platform to pass through to the user. But doing so takes up a lot of
    // space in the rx buffer, so despite the inconvenience, for performance
    // reasons, I am going to have to require that messages containing all
    // zeroes never be sent by the user.
    bool rx_current_all_zeroes = true;

    int transmit_busy_count = 0;


    int tx_iter_state = 0;
    TxInfo* tx_current_message = nullptr;

    int null_bytes_written = 0;

    bool is_host = false;

    RxInfo* poller_current_message = nullptr;


    MultiplayerComms()
        : tx_message_pool("transmit-packet-pool"),
          rx_message_pool("receive-packet-pool")
    {
    }
};



static MultiplayerComms multiplayer_comms;



static TxInfo* tx_ring_pop()
{
    auto& mc = multiplayer_comms;


    TxInfo* msg = nullptr;

    for (int i = mc.tx_ring_read_pos; i < mc.tx_ring_read_pos + mc.tx_ring_size;
         ++i) {
        auto index = i % mc.tx_ring_size;
        if (mc.tx_ring[index]) {
            msg = mc.tx_ring[index];
            mc.tx_ring[index] = nullptr;
            mc.tx_ring_read_pos = index;
            return msg;
        }
    }

    mc.tx_ring_read_pos += 1;
    mc.tx_ring_read_pos %= mc.tx_ring_size;

    // The transmit ring is completely empty!
    return nullptr;
}



static void rx_ring_push(RxInfo* message)
{
    auto& mc = multiplayer_comms;

    mc.rx_message_count += 1;

    if (mc.rx_ring[mc.rx_ring_write_pos]) {
        // The reader does not seem to be keeping up!
        mc.rx_loss += 1;

        auto lost_message = mc.rx_ring[mc.rx_ring_write_pos];

        mc.rx_ring[mc.rx_ring_write_pos] = nullptr;
        mc.rx_message_pool.free(lost_message);
    }

    mc.rx_ring[mc.rx_ring_write_pos] = message;
    mc.rx_ring_write_pos += 1;
    mc.rx_ring_write_pos %= mc.rx_ring_size;
}



static RxInfo* rx_ring_pop()
{
    auto& mc = multiplayer_comms;

    RxInfo* msg = nullptr;

    for (int i = mc.rx_ring_read_pos; i < mc.rx_ring_read_pos + mc.rx_ring_size;
         ++i) {
        auto index = i % mc.rx_ring_size;

        if (mc.rx_ring[index]) {
            msg = mc.rx_ring[index];
            mc.rx_ring[index] = nullptr;
            mc.rx_ring_read_pos = index;

            return msg;
        }
    }

    mc.rx_ring_read_pos += 1;
    mc.rx_ring_read_pos %= mc.rx_ring_size;

    return nullptr;
}



static void multiplayer_rx_receive()
{
    auto& mc = multiplayer_comms;

    if (mc.rx_iter_state == message_iters) {
        if (mc.rx_current_message) {
            if (mc.rx_current_all_zeroes) {
                mc.rx_message_pool.free(mc.rx_current_message);
            } else {
                rx_ring_push(mc.rx_current_message);
            }
        }

        mc.rx_current_all_zeroes = true;

        mc.rx_current_message = mc.rx_message_pool.alloc();
        if (not mc.rx_current_message) {
            mc.rx_loss += 1;
        }
        mc.rx_iter_state = 0;
    }

    if (mc.rx_current_message) {
        const auto val =
            multiplayer_is_master() ? REG_SIOMULTI1 : REG_SIOMULTI0;
        if (mc.rx_current_all_zeroes and val) {
            mc.rx_current_all_zeroes = false;
        }
        mc.rx_current_message->data_[mc.rx_iter_state++] = val;

    } else {
        mc.rx_iter_state++;
    }
}



static bool multiplayer_busy()
{
    return REG_SIOCNT & SIO_START;
}



int Platform::NetworkPeer::send_queue_capacity() const
{
    return MultiplayerComms::tx_ring_size;
}



int Platform::NetworkPeer::send_queue_size() const
{
    int result = 0;

    for (auto ptr : multiplayer_comms.tx_ring) {
        if (ptr) {
            ++result;
        }
    }

    return result;
}



bool Platform::NetworkPeer::send_message(const Message& message)
{
    if (message.length_ > sizeof(TxInfo::data_)) {
        ::__platform__->fatal("invalid network packet size");
    }

    if (not is_connected()) {
        return false;
    }

    // TODO: uncomment this block if we actually see issues on the real hardware...
    // if (tx_iter_state == message_iters) {
    //     // Decreases the likelihood of manipulating data shared by the interrupt
    //     // handlers. See related comment in the poll_message() function.
    //     return false;
    // }

    auto& mc = multiplayer_comms;


    if (mc.tx_ring[mc.tx_ring_write_pos]) {
        // The writer does not seem to be keeping up! Guess we'll have to drop a
        // message :(
        mc.tx_loss += 1;

        auto lost_message = mc.tx_ring[mc.tx_ring_write_pos];
        mc.tx_ring[mc.tx_ring_write_pos] = nullptr;

        mc.tx_message_pool.free(lost_message);
    }

    auto msg = mc.tx_message_pool.alloc();
    if (not msg) {
        // error! Could not transmit messages fast enough, i.e. we've exhausted
        // the message pool! How to handle this condition!?
        mc.tx_loss += 1;
        return false;
    }

    __builtin_memcpy(msg->data_, message.data_, message.length_);

    mc.tx_ring[mc.tx_ring_write_pos] = msg;
    mc.tx_ring_write_pos += 1;
    mc.tx_ring_write_pos %= mc.tx_ring_size;

    return true;
}



static void multiplayer_tx_send()
{
    auto& mc = multiplayer_comms;

    if (mc.tx_iter_state == message_iters) {
        if (mc.tx_current_message) {
            mc.tx_message_pool.free(mc.tx_current_message);
            mc.tx_message_count += 1;
        }
        mc.tx_current_message = tx_ring_pop();
        mc.tx_iter_state = 0;
    }

    if (mc.tx_current_message) {
        REG_SIOMLT_SEND = mc.tx_current_message->data_[mc.tx_iter_state++];
    } else {
        mc.null_bytes_written += 2;
        mc.tx_iter_state++;
        REG_SIOMLT_SEND = 0;
    }
}



// We want to wait long enough for the minions to prepare TX data for the
// master.
static void multiplayer_schedule_master_tx()
{
    REG_TM2CNT_H = 0x00C1;
    REG_TM2CNT_L = 65000; // Be careful with this delay! Due to manufacturing
                          // differences between Gameboy Advance units, you
                          // really don't want to get too smart, and try to
                          // calculate the time right up to the boundary of
                          // where you expect the interrupt to happen. Allow
                          // some extra wiggle room, for other devices that may
                          // raise a serial receive interrupt later than you
                          // expect. Maybe, this timer could be sped up a bit,
                          // but I don't really know... here's the thing, this
                          // code CURRENTLY WORKS, so don't use a faster timer
                          // interrupt until you've tested the code on a bunch
                          // different real gba units (try out the code on the
                          // original gba, both sp models, etc.)

    irqEnable(IRQ_TIMER2);
    irqSet(IRQ_TIMER2, [] {
        if (multiplayer_busy()) {
            ++multiplayer_comms.transmit_busy_count;
            return; // still busy, try again. The only thing that should kick
                    // off this timer, though, is the serial irq, and the
                    // initial connection, so not sure how we could get into
                    // this state.
        } else {
            irqDisable(IRQ_TIMER2);
            multiplayer_tx_send();
            REG_SIOCNT = REG_SIOCNT | SIO_START;
        }
    });
}



static void multiplayer_schedule_tx()
{
    // If we're the minion, simply enter data into the send queue. The
    // master will wait before initiating another transmit.
    if (multiplayer_is_master()) {
        multiplayer_schedule_master_tx();
    } else {
        multiplayer_tx_send();
    }
}



static void multiplayer_serial_isr()
{
    if (UNLIKELY(multiplayer_error())) {
        ::__platform__->network_peer().disconnect();
        return;
    }

    multiplayer_comms.is_host = multiplayer_is_master();

    multiplayer_rx_receive();
    multiplayer_schedule_tx();
}



std::optional<Platform::NetworkPeer::Message>
Platform::NetworkPeer::poll_message()
{
    auto& mc = multiplayer_comms;

    if (mc.rx_iter_state == message_iters) {
        // This further decreases the likelihood of messing up the receive
        // interrupt handler by manipulating shared data. We really should be
        // declaring stuff volatile and disabling interrupts, but we cannot
        // easily do those things, for various practical reasons, so we're just
        // hoping that a problematic interrupt during a transmit or a poll is
        // just exceedingly unlikely in practice. The serial interrupt handler
        // runs approximately twice per frame, and the game only transmits a few
        // messages per second. Furthermore, the interrupt handlers only access
        // shared state when rx_iter_state == message_iters, so only one in six
        // interrupts manipulates shared state, i.e. only one occurrence every
        // three or so frames. And for writes to shared data to even be a
        // problem, the interrupt would have to occur between two instructions
        // when writing to the message ring or to the message pool. And on top
        // of all that, we are leaving packets in the rx buffer while
        // rx_iter_state == message iters, so we really shouldn't be writing at
        // the same time anyway. So in practice, the possibility of manipulating
        // shared data is just vanishingly small, although I acknowledge that
        // it's a potential problem. There _IS_ a bug, but I've masked it pretty
        // well (I hope). No issues detectable in an emulator, but we'll see
        // about the real hardware... once my link cable arrives in the mail.
        // P.S.: Tested on actual hardware, works fine.
        return {};
    }
    if (auto msg = rx_ring_pop()) {
        if (UNLIKELY(mc.poller_current_message not_eq nullptr)) {
            // failure to deallocate/consume message!
            mc.rx_message_pool.free(msg);
            disconnect();
            return {};
        }
        mc.poller_current_message = msg;
        return Platform::NetworkPeer::Message{
            reinterpret_cast<u8*>(msg->data_),
            static_cast<int>(sizeof(WireMessage::data_))};
    }
    return {};
}



void Platform::NetworkPeer::poll_consume(u32 size)
{
    auto& mc = multiplayer_comms;

    if (mc.poller_current_message) {
        mc.rx_message_pool.free(mc.poller_current_message);
    } else {
        ::__platform__->fatal("logic error in net poll");
    }
    mc.poller_current_message = nullptr;
}



static void multiplayer_init()
{
    Microseconds delta = 0;

MASTER_RETRY:
    ::__platform__->network_peer().disconnect();

    ::__platform__->sleep(5);

    REG_RCNT = R_MULTI;
    REG_SIOCNT = SIO_MULTI;
    REG_SIOCNT = REG_SIOCNT | SIO_IRQ | SIO_115200;

    irqEnable(IRQ_SERIAL);
    irqSet(IRQ_SERIAL, multiplayer_serial_isr);

    // Put this here for now, not sure whether it's really necessary...
    REG_SIOMLT_SEND = 0x5555;

    ::__platform__->delta_clock().reset();

    while (not multiplayer_validate()) {
        delta += ::__platform__->delta_clock().reset();
        if (delta > seconds(20)) {
            if (not multiplayer_validate_modes()) {
                error("not all GBAs are in MULTI mode");
            }
            ::__platform__->network_peer()
                .disconnect(); // just for good measure
            REG_SIOCNT = 0;
            irqDisable(IRQ_SERIAL);
            return;
        }
        ::__platform__->system_call("feed-watchdog", nullptr);
    }

    const char* handshake =
        "lnsk06"; // Link cable program, skyland, 6 byte packet.

    if (strlen(handshake) not_eq Platform::NetworkPeer::max_message_size) {
        ::__platform__->network_peer().disconnect();
        error("handshake string does not equal message size");
        return;
    }

    set_gflag(GlobalFlag::multiplayer_connected, true);

    ::__platform__->network_peer().send_message(
        {(u8*)handshake, sizeof handshake});

    multiplayer_schedule_tx();

    if (multiplayer_is_master()) {
        info("I am the master");
    }

    while (true) {
        ::__platform__->system_call("feed-watchdog", nullptr);
        delta += ::__platform__->delta_clock().reset();
        if (delta > seconds(20)) {
            StringBuffer<64> err =
                "no valid handshake received within a reasonable window ";
            err += stringify(multiplayer_comms.rx_message_count);
            error(err.c_str());
            ::__platform__->network_peer().disconnect();
            return;
        } else if (auto msg = ::__platform__->network_peer().poll_message()) {
            for (u32 i = 0; i < sizeof handshake; ++i) {
                if (((u8*)msg->data_)[i] not_eq handshake[i]) {
                    if (multiplayer_is_master()) {
                        // For the master, if none of the other GBAs are in
                        // multi serial mode yet, the SIOCNT register will show
                        // that all gbas are in a ready state (all of one
                        // device). The master will, therefore, push out a
                        // message, and receive back garbage data. So we want to
                        // keep retrying, in order to account for the scenario
                        // where the other device is not yet plugged in, or the
                        // other player has not initiated their own connection.
                        info("master retrying...");

                        StringBuffer<32> temp = "got: ";
                        for (u32 i = 0; i < sizeof handshake; ++i) {
                            temp.push_back(((char*)msg->data_)[i]);
                        }
                        info(temp.c_str());

                        // busy-wait for a bit. This is sort of necessary;
                        // Platform::sleep() does not contribute to the
                        // delta clock offset (by design), so if we don't
                        // burn up some time here, we will take a _long_
                        // time to reach the timeout interval.
                        busy_wait(10000);
                        goto MASTER_RETRY; // lol yikes a goto
                    } else {
                        ::__platform__->network_peer().disconnect();
                        info("invalid handshake");
                        return;
                    }
                }
            }
            info("validated handshake");
            ::__platform__->network_peer().poll_consume(sizeof handshake);
            return;
        }
    }
}



void Platform::NetworkPeer::connect(const char* peer)
{
    // If the gameboy player is active, any multiplayer initialization would
    // clobber the Normal_32 serial transfer between the gameboy player and the
    // gameboy advance.
    if (get_gflag(GlobalFlag::gbp_unlocked)) {
        return;
    }

    audio_update_swap(audio_update_fast_cb);

    multiplayer_init();
}



void Platform::NetworkPeer::listen()
{
    if (get_gflag(GlobalFlag::gbp_unlocked)) {
        return;
    }

    multiplayer_init();
}



void Platform::NetworkPeer::update()
{
}



bool Platform::NetworkPeer::is_connected() const
{
    return get_gflag(GlobalFlag::multiplayer_connected);
}



bool Platform::NetworkPeer::is_host() const
{
    return multiplayer_comms.is_host;
}



void Platform::NetworkPeer::disconnect()
{
    // Be very careful editing this function. We need to get ourselves back to a
    // completely clean slate, otherwise, we won't be able to reconnect (e.g. if
    // you leave a message sitting in the transmit ring, it may be erroneously
    // sent out when you try to reconnect, instead of the handshake message);
    if (is_connected()) {

        info("disconnected!");
        set_gflag(GlobalFlag::multiplayer_connected, false);
        irqDisable(IRQ_SERIAL);
        irqDisable(IRQ_TIMER2);
        REG_SIOCNT = 0;

        auto& mc = multiplayer_comms;

        if (mc.poller_current_message) {
            // Not sure whether this is the correct thing to do here...
            mc.rx_message_pool.free(mc.poller_current_message);
            mc.poller_current_message = nullptr;
        }

        mc.rx_iter_state = 0;
        if (mc.rx_current_message) {
            mc.rx_message_pool.free(mc.rx_current_message);
            mc.rx_current_message = nullptr;
        }
        mc.rx_current_all_zeroes = true;
        for (auto& msg : mc.rx_ring) {
            if (msg) {
                StringBuffer<32> note = "consumed msg containing ";
                note.push_back(((char*)msg->data_)[0]);
                note.push_back(((char*)msg->data_)[1]);
                note.push_back(((char*)msg->data_)[2]);
                note.push_back(((char*)msg->data_)[4]);
                note.push_back(((char*)msg->data_)[5]);
                note += " during disconnect";
                info(note.c_str());
                mc.rx_message_pool.free(msg);
                msg = nullptr;
            }
        }
        mc.rx_ring_write_pos = 0;
        mc.rx_ring_read_pos = 0;

        mc.tx_iter_state = 0;
        if (mc.tx_current_message) {
            mc.tx_message_pool.free(mc.tx_current_message);
            mc.tx_current_message = nullptr;
        }
        for (auto& msg : mc.tx_ring) {
            if (msg) {
                mc.tx_message_pool.free(msg);
                msg = nullptr;
            }
        }
        mc.tx_ring_write_pos = 0;
        mc.tx_ring_read_pos = 0;
    }
}



Platform::NetworkPeer::Interface Platform::NetworkPeer::interface() const
{
    return Interface::serial_cable;
}



Platform::NetworkPeer::~NetworkPeer()
{
    // ...
}
