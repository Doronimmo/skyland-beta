
 This document assumes that
 you have the SKYLAND engine
 ROM separated from its
 filesystem, and you're
 designing levels.

 This document also assumes
 that you're a hacker who
 wants to mod SKYLAND.

 I build SKYLAND in two
 separate parts: the engine,
 a finely-tuned C++
 application, and LISP
 scripts. If you find the
 _FS symbol in the ROM,
 you can split the ROM in
 two, before _FS, yielding
 the engine and filesystem
 as two separate parts.

 You should find the
 filesystem exceedingly
 simple in structure.

 The filesystem begins with
 a Root block. In C:

 struct Root {
     char magic_[4];
     host_u32 file_count_;
 };

 magic_ contains the
 aforementioned _FS text,
 along with a version number.

 file_count_ represents the
 number of files in the
 archive.

 NOTE: file_count_ is a
 thirty-two bit integer, in
 host byte order.

 After the Root structure,
 you'll find a FileHeader
 structure.

 struct FileHeader {
     char path_[64];
     host_u32 size_;
 };

 path_ should contain a
 null terminated string
 representing a file path.
 size_ store the size of
 the file, in bytes. Each
 file must be null-
 terminated, regardless
 of the file contents.

 After the file header,
 you'll find the file data.

 You'll find FileHeader
 followed by file data
 repeatedly, for each
 file in the archive.

 Due to the simplicity
 of the format, you should
 be able to unpack the format
 without much trouble. But
 just in case, here's my own
 script for encoding files.
 I basically just run this
 script, and create a
 Skyland.gba by running:

 cat SkylandEngine.gba fs.bin > Skyland.gba


import sys
import os


project_root_path = os.path.split(os.path.dirname(os.path.realpath(__file__)))[0]



def encode_file(path, real_name, out):
    with open(path) as test_file:
        encoded_path = real_name.encode('utf-8')

        if len(encoded_path) > 63:
            print("path %s too long" % real_name)
            sys.exit()

        out.write(encoded_path)

        for i in range(len(encoded_path), 64):
            out.write('\0'.encode('utf-8'))

        data = test_file.read()
        file_contents = data.encode('utf-8')

        # +1 for null terminator
        out.write((len(file_contents) + 1).to_bytes(4, 'little'))

        out.write(file_contents)
        out.write('\0'.encode('utf-8'))



def collect_paths(paths_list, subdir):
    for root, dirs, files in os.walk(os.path.join(project_root_path, subdir), topdown=False):

        if dirs:
            dirs.sort()
        if files:
            files.sort()

        for sdir in dirs:
            collect_paths(paths_list, subdir + '/' + sdir)
        for name in files:
            if os.path.basename(root) == subdir.split('/')[-1]:
                full = os.path.join('/' + subdir, name)
                if not '~' in full:
                    paths_list.append(['/' + subdir + '/' + name, os.path.join(root, name)])



with open('fs.bin', 'wb') as filesystem:
    print("creating fs.bin...")

    filesystem.write("_FS_".encode('utf-8'))

    files_list = []

    collect_paths(files_list, "scripts")
    collect_paths(files_list, "strings")
    collect_paths(files_list, "help")
    collect_paths(files_list, "misc")

    files_list.append(["/readme.txt", os.path.join(project_root_path, "readme.txt")])

    fs_count = len(files_list)
    print("encoding %d files..." % fs_count)

    filesystem.write(fs_count.to_bytes(4, 'little'))

    for info in files_list:
        encode_file(info[1], info[0], filesystem)

    print('done!')
