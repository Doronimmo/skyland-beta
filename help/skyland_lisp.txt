
  '(SKYLAND LISP)

 You may be wondering, why
 lisp? I never intended to
 write a lisp interpreter.
 
 I started out with a simple
 cheat system, where I could
 enter numeric codes to test
 certain behavior. But I
 couldn't remember any of the
 numeric codes, so I wrote a
 little command-prompt.
 
 Then often found myself
 wanting to write compound
 expressions, and lisp
 was the easiest thing to
 write a parser for. Over
 the years, the interpreter
 snowballed into a lexically-
 scoped scheme-inspired lisp
 with an optimizing bytecode
 compiler...


 Generally, you should refer
 to the existing game scripts
 for examples of how to use
 the engine's scripting
 language.

 SKYLAND lisp is a bit of a
 mix of scheme and common
 lisp.

 I won't give an in-depth
 description of the entire
 language. But I should
 mention a few notable
 differences from other lisp
 dialects. In almost all
 cases, the seemingly weird
 language design choices
 listed below result from
 gba hardware limitations.

 1) While the language does
 support named arguments for
 functions, the older version
 of the interpreter only
 featured unnamed arguments,
 referenced by the $ symbol
 followed by the argument
 number. The interpreter
 does now support lambdas
 with named arguments, but
 the older (fn ...) syntax
 still exists in many
 scripts. I am slowly
 replacing it.

 Furthermore, the named
 argument syntax is built
 on top of the numbered
 positional argument syntax,
 so you may notice $ symbols
 in place of argument variable
 names in error messages.

 2) The language does not
 allow you to capture a
 function argument as part of
 a closure, you have to
 manually create a let
 binding. Mostly for reasons
 hinted at in 1). I'll fix
 this someday.

 3) The reader (read) performs
 macro expansion. With very
 limited cpu, macroexpanding
 a function each time you call
 it just isn't realistic.
